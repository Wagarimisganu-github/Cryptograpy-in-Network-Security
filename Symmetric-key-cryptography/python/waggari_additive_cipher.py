# -*- coding: utf-8 -*-
"""Waggari_Additive cipher.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1LfOBa2Sp6by-Hi_JXoJb_3NbdqXXGXdV

🔐 Additive Cipher (Caesar Cipher)
📘 1. Introduction
The Additive Cipher is a substitution cipher where each letter in the plaintext is shifted by a fixed number of positions (called the key) in the alphabet.
•	It is one of the oldest encryption techniques.
•	It belongs to the family of symmetric key cryptography.
•	The key is the number of positions to shift.
🔑 2. Algorithm
📥 Encryption Algorithm
Let:
•	P be the position of the plaintext character (0 to 25)
•	K be the key (shift)
•	C be the position of the cipher character
Formula:
C = (P + K) mod 26
📤 Decryption Algorithm
Let:
•	C be the position of the cipher character
•	K be the key
•	P be the recovered position of the plaintext character
Formula:
P = (C - K) mod 26
All letters are converted to uppercase, and only alphabetic characters are processed.

💡 3. Application Areas
•	Early military communications
•	Basic information hiding in educational tools
•	Fundamental teaching tool in cryptography education
•	Not used for secure communication today due to its simplicity

Prepared By **Waggari Misganu Ebsa**( **Certified in Cyber Security**), **Msc in Computer Science**
"""



# 🔐 Additive Cipher (Caesar Cipher) with Full Encryption/Decryption

def additive_encrypt(message, key):
    cipher = ''
    for char in message.upper():
        if char.isalpha():
            cipher += chr((ord(char) - 65 + key) % 26 + 65)
        else:
            cipher += char
    return cipher

def additive_decrypt(cipher, key):
    decrypted = ''
    for char in cipher:
        if char.isalpha():
            decrypted += chr((ord(char) - 65 - key) % 26 + 65)
        else:
            decrypted += char
    return decrypted

# Accept user input
message = input("Enter your plaintext message (letters only): ").strip()
key = int(input("Enter the key (0-25): "))

# Encrypt
cipher_text = additive_encrypt(message, key)
print("\nEncrypted message:", cipher_text)

# Decrypt
decrypted_message = additive_decrypt(cipher_text, key)
print("Decrypted message:", decrypted_message)

# Verify match
if decrypted_message == message.upper():
    print("\n✅ Decryption is successful and matches the original plaintext.")
else:
    print("\n❌ Decryption failed. The result does not match the original.")