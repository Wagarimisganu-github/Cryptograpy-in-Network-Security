# -*- coding: utf-8 -*-
"""Waggari_Multplicative ciphers.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1sCQUK539fDldX9BpiS3s1oBJynVJXwYp

üîê Multiplicative Cipher

üìò 1. Introduction
The Multiplicative Cipher is a type of monoalphabetic substitution cipher that transforms each letter of the plaintext into another letter by multiplying its position in the alphabet by a key and applying modulo 26.
‚Ä¢	It‚Äôs part of symmetric key encryption.
‚Ä¢	Unlike the Additive Cipher, it involves modular multiplication.
‚Ä¢	The key must be coprime with 26 to ensure decryption is possible.

üßÆ 2. Algorithm
Let:
‚Ä¢	P = Position of the plaintext letter (0‚Äì25)
‚Ä¢	K = Encryption key (must be coprime with 26)
‚Ä¢	C = Encrypted character
‚Ä¢	K_inv = Modular inverse of K (used in decryption)
‚úÖ Encryption:
C = (P √ó K) mod 26
‚úÖ Decryption:
P = (C √ó K_inv) mod 26
Where:
‚Ä¢	The modular inverse K_inv is a number such that (K √ó K_inv) % 26 == 1.

üìå 3. Valid Keys
Only numbers coprime with 26 can be used as keys. Valid values:
1, 3, 5, 7, 9, 11, 15, 17, 19, 21, 23, 25
________________________________________
üí° 5. Application Areas
‚Ä¢	Early cryptographic methods for secure communication
‚Ä¢	Educational tool for learning modular arithmetic and cryptography
‚Ä¢	Component in more complex ciphers like Affine Cipher
________________________________________

Prepared By **Waggari Misganu Ebsa**( **Certified in Cyber Security**), **Msc in Computer Science**
"""

# üîê Multiplicative Cipher Implementation

def is_coprime(a, b):
    while b != 0:
        a, b = b, a % b
    return a == 1

def mod_inverse(key, mod=26):
    for x in range(1, mod):
        if (key * x) % mod == 1:
            return x
    return None

def multiplicative_encrypt(message, key):
    cipher = ''
    for char in message.upper():
        if char.isalpha():
            cipher += chr(((ord(char) - 65) * key) % 26 + 65)
        else:
            cipher += char
    return cipher

def multiplicative_decrypt(cipher, key):
    key_inv = mod_inverse(key, 26)
    if key_inv is None:
        raise ValueError("No modular inverse for the key exists. Decryption not possible.")

    plain = ''
    for char in cipher:
        if char.isalpha():
            plain += chr(((ord(char) - 65) * key_inv) % 26 + 65)
        else:
            plain += char
    return plain

# Input from user
message = input("Enter the message (letters only): ")
key = int(input("Enter the key (must be coprime with 26): "))

if not is_coprime(key, 26):
    print("‚ùå Invalid key. It must be coprime with 26.")
else:
    cipher_text = multiplicative_encrypt(message, key)
    print("\nEncrypted message:", cipher_text)

    decrypted_message = multiplicative_decrypt(cipher_text, key)
    print("Decrypted message:", decrypted_message)

    # Verify
    if decrypted_message == message.upper():
        print("\n‚úÖ Decryption successful and matches the original plaintext.")
    else:
        print("\n‚ùå Decryption failed. The result does not match the original.")