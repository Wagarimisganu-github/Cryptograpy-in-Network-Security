# -*- coding: utf-8 -*-
"""Waggari_AES.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1k7dSWyiGYDW-5-1VfBqing41BsTMJWzF

ğŸ” AES (Advanced Encryption Standard)
ğŸ“˜ 1. Introduction
AES (Advanced Encryption Standard) is the current U.S. federal standard for symmetric key encryption, adopted by NIST in 2001.

Based on the Rijndael cipher

Uses a block size of 128 bits (16 bytes)

Supports key sizes of 128, 192, or 256 bits

Extremely fast and secure for modern applications

ğŸ§® 2. AES Algorithm Overview
AES operates on a 4Ã—4 column-major order matrix of bytes, called the state.

âœ… Main Steps in AES:
Key Expansion

Initial Round

AddRoundKey

Rounds (repeated):

SubBytes

ShiftRows

MixColumns

AddRoundKey

Final Round (without MixColumns)

âœ… Encryption & Decryption Flow
Encryption and decryption follow the same steps with reverse operations during decryption.

Secure and efficient due to substitutionâ€“permutation network structure.

ğŸ”‘ 3. AES Parameters
Key Size	No. of Rounds
128-bit	10
192-bit	12
256-bit	14

ğŸ’¡ 4. Application Areas of AES
AES is the industry standard and used in:

TLS/SSL (HTTPS web encryption)

Wi-Fi security (WPA2/WPA3)

Secure file storage (e.g., BitLocker, VeraCrypt)

Mobile communication (Signal, WhatsApp)

Banking systems and credit card transactions

Prepared By **Waggari Misganu Ebsa**( **Certified in Cyber Security**), **Msc in Computer Science**
"""

pip install pycryptodome

# ğŸ” AES Encryption/Decryption using PyCryptodome

from Crypto.Cipher import AES
from Crypto.Util.Padding import pad, unpad
from Crypto.Random import get_random_bytes

# AES block size is fixed at 16 bytes (128 bits)
BLOCK_SIZE = AES.block_size  # 16

# Get input message
message = input("Enter the message to encrypt (any length): ").encode()

# Generate a secure 16-byte AES key
key = get_random_bytes(16)
print("ğŸ”‘ AES Key (hex):", key.hex())

# Generate a random IV for CBC mode
iv = get_random_bytes(16)
print("ğŸ“¥ Initialization Vector (IV) (hex):", iv.hex())

# Encrypt using AES CBC mode
cipher = AES.new(key, AES.MODE_CBC, iv)
ciphertext = cipher.encrypt(pad(message, BLOCK_SIZE))
print("ğŸ”’ Encrypted (hex):", ciphertext.hex())

# Decrypt
decipher = AES.new(key, AES.MODE_CBC, iv)
decrypted_padded = decipher.decrypt(ciphertext)
decrypted = unpad(decrypted_padded, BLOCK_SIZE)

print("ğŸ”“ Decrypted message:", decrypted.decode())

# Verification
if decrypted.decode() == message.decode():
    print("\nâœ… Decryption successful and matches original plaintext.")
else:
    print("\nâŒ Decryption failed.")